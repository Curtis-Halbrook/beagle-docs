<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beagle â€“ Advanced topics</title>
    <link>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/</link>
    <description>Recent content in Advanced topics on Beagle</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Data structure</title>
      <link>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/data-structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/data-structure/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h2 id=&#34;how-does-beagle-represent-a-view&#34;&gt;How does Beagle represent a view?&lt;/h2&gt;


&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;

The features described here are only available in versions 1.2.0 and above.
&lt;/div&gt;

&lt;p&gt;Beagle works over a tree of components and in order to work, it must follow some rules. In Typescript terms, Beagle Tree can be defined as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;export interface BeagleUIElement {
  _beagleComponent_: string,
  id: string,
  context?: DataContext,
  children?: BeagleUIElement[],
  style?: Style,
  [key: string]: any,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See below every tree&amp;rsquo;s componenent:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_beagleComponent_&lt;/code&gt; is the name of the UI component to render.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; is a unique identifier for the node. Observation: although the &lt;code&gt;id&lt;/code&gt; is required by the internal tree structure, before processing the tree, Beagle assigns random unique ids for each node without an id, making it optional in the json provided by the backend.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;context&lt;/code&gt; is a &lt;a href=&#34;../../../../comunication-between-components-and-context.md&#34;&gt;&lt;strong&gt;context&lt;/strong&gt;&lt;/a&gt; defined for the component and its children.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;children&lt;/code&gt; is an array of nodes representing the children of the current node.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;style&lt;/code&gt; is the stylization rules for the component. These rules are not CSS, instead it&amp;rsquo;s a &lt;a href=&#34;https://docs.usebeagle.io/resources/estilizacao/web#stylizing-components-through-json&#34;&gt;&lt;strong&gt;structure defined by Beagle&lt;/strong&gt;&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Additionally, a node has every property expected by the component itself, a text component could have &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;justify&lt;/code&gt;, while a button could have &lt;code&gt;onPress&lt;/code&gt;, &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;disabled&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Below, we show an example of a tree of components ready to be processed by Beagle:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;{
  &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;container&amp;#34;,
  &amp;#34;id&amp;#34;: &amp;#34;container&amp;#34;,
  &amp;#34;children&amp;#34;: [
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;image&amp;#34;,
      &amp;#34;id&amp;#34;: &amp;#34;logo&amp;#34;,
      &amp;#34;url&amp;#34;: &amp;#34;https://i.ibb.co/rvRN9kv/logo.png&amp;#34;
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;text&amp;#34;,
      &amp;#34;id&amp;#34;: &amp;#34;welcome&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;Welcome to the Beagle playground!&amp;#34;
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;text&amp;#34;,
      &amp;#34;id&amp;#34;: &amp;#34;instructions&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;Use the panel on the left to start coding!&amp;#34;
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;button&amp;#34;,
      &amp;#34;id&amp;#34;: &amp;#34;fast-guide&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;Access the fast guide&amp;#34;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The json above is a simpler version of the welcome page of the Beagle Playground website. It renders a container to hold the rest of the elements: an image, two texts and a button. To see the full example and the UI rendered by it, access the &lt;a href=&#34;https://beagle-playground.netlify.app/&#34;&gt;&lt;strong&gt;Beagle Playground&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-beagle-payload&#34;&gt;The Beagle Payload&lt;/h2&gt;
&lt;p&gt;The type defined in the last section (&lt;code&gt;BeagleUIElement&lt;/code&gt;), you can see the &lt;code&gt;id&lt;/code&gt; is a required property and that the children of a node must always be named &lt;code&gt;children&lt;/code&gt;. The backend, however, may not guarantee any of that. For this reason, Beagle internally generates unique ids for every node without one and translates the children property. A table component, for instance, might have its children in the property &lt;code&gt;rows&lt;/code&gt;. Before starting to process, Beagle converts &lt;code&gt;rows&lt;/code&gt; to the expected name &lt;code&gt;children&lt;/code&gt; (see section &lt;a href=&#34;data-structure.md#the-children-property&#34;&gt;&lt;strong&gt;The &lt;code&gt;children&lt;/code&gt; property&lt;/strong&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In fact, the payload returned by the backend can be anything, but internally Beagle must work with a tree of components (&lt;code&gt;BeagleUIElement&lt;/code&gt;). You must be able to traverse the tree and detect every component and its children. The payload can be anything, because it gives the developer a chance to change it before it gets processed by Beagle.&lt;/p&gt;
&lt;p&gt;We recommend that the backend always return a JSON representing a tree of components, as it is expected by Beagle, but if, for some reason, it is not possible, Beagle Web makes it possible to pre-process the response and build the tree in the front-end before Beagle actually works upon it, like in &lt;a href=&#34;rendering.md#lifecycles&#34;&gt;&lt;strong&gt;lifecycles&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;the-children-property&#34;&gt;The children property&lt;/h3&gt;
&lt;p&gt;You should always use an array named &lt;code&gt;children&lt;/code&gt; to specify the child nodes of a component. But, Beagle will work out of the box, if instead of an array of components, a single node is passed, and will also work if the name &lt;code&gt;child&lt;/code&gt; is used.&lt;/p&gt;
&lt;p&gt;If a component that represents a table, the children might be named &lt;code&gt;rows&lt;/code&gt; instead of &lt;code&gt;children&lt;/code&gt;, in this case, you can inform Beagle that, for this specific component, the name of the property &lt;code&gt;children&lt;/code&gt; is different. See the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;@BeagleChildren({ property: &amp;#39;rows&amp;#39; })
@Component({
  // ...
})
class Table {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The example above is for Angular, but it would work the same way in other platforms. If your component is functional or if you don&amp;rsquo;t want to use decorators (annotations), you can use it as a function, see the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const Table = (props) =&amp;gt; {
  // ...
}

BeagleChildren({ property: &amp;#39;rows&amp;#39; })(Table)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: The Beagle View</title>
      <link>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/the-beagle-view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/the-beagle-view/</guid>
      <description>
        
        
        &lt;hr&gt;
&lt;h2 id=&#34;accessing-and-controlling-the-beagleview&#34;&gt;Accessing and controlling the BeagleView&lt;/h2&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

The features described here are only available in versions 1.2.0 and above.
&lt;/div&gt;

&lt;p&gt;The Beagle View is the entity responsible to manage a server-driven view. It can be created through the Beagle Service via the function &lt;code&gt;createBeagleView&lt;/code&gt;. The BeagleView can fetch a new view, update its tree, navigate, etc.&lt;/p&gt;
&lt;h2 id=&#34;accessing-the-beagle-view&#34;&gt;Accessing the Beagle View&lt;/h2&gt;
&lt;p&gt;A Beagle View is created in Angular or React when the component &lt;code&gt;BeagleRemoteView&lt;/code&gt; is used. To get access to it, you should use the property &lt;code&gt;onCreateBeagleView&lt;/code&gt;, in Angular, or &lt;code&gt;viewRef&lt;/code&gt; in React.&lt;/p&gt;
&lt;p&gt;See the examples below:&lt;/p&gt;
&lt;h3 id=&#34;angular&#34;&gt;&lt;strong&gt;Angular&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&amp;lt;beagle-remote-view [loadParams]=&amp;#34;loadParams&amp;#34; (onCreateBeagleView)=&amp;#34;onCreateBeagleView($event)&amp;#34;&amp;gt;
beagle-remote-view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { Component } from &amp;#39;@angular/core&amp;#39;
import { BeagleView } from &amp;#39;@zup-it/beagle-web&amp;#39;

@Component({
  // ...
})
class MyComponent {
  private beagleView: BeagleView | undefined

  // ...

  logBeagleView() {
    if (!this.beagleView) return
    console.log(this.beagleView))
  }

  onCreateBeagleView(beagleView) {
    this.beagleView = beagleView
    this.logBeagleView()
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;react&#34;&gt;&lt;strong&gt;React&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import React, { useRef, MutableRefObject, useEffect } from &amp;#39;react&amp;#39;
import { BeagleRemoteView } from &amp;#39;@zup-it/beagle-react&amp;#39;
import { BeagleView } from &amp;#39;@zup-it/beagle-web&amp;#39;

const MyComponent: FC = () =&amp;gt; {
  const beagleView = useRef() as MutableRefObject&amp;lt;BeagleView | undefined&amp;gt;

  // ...

  logBeagleView() {
    if (!beagleView.current) return
    console.log(beagleView.current)
  }

  useEffect(logBeagleView, [])

  return &amp;lt;BeagleRemoteView path=&amp;#34;/my-path&amp;#34; viewRef={beagleView} /&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the examples above, we accessed the Beagle View and logged it. It is important to notice that you need to check for the Beagle View availability before using it. Since the Beagle View is created by a child component, it won&amp;rsquo;t be available before the children components are created.&lt;/p&gt;
&lt;h2 id=&#34;fetching-a-view&#34;&gt;Fetching a view&lt;/h2&gt;
&lt;p&gt;To fetch a view from the backend and update the current view, you need to use the method &lt;code&gt;fetch&lt;/code&gt; of the &lt;code&gt;BeagleView&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A fetch operation can be over the entire tree or just a branch. If it&amp;rsquo;s the entire tree, it gets replaced by the result of the request. Otherwise, the tree is kept the same, but for the branch you use &lt;code&gt;fetch&lt;/code&gt; to update, this specific branch will get replaced by the result of the request. See an example of a call to the function &lt;code&gt;fetch&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;// fetches the remote view at /my-path and uses it to replace the entire current view
beagleView.fetch({ path: &amp;#39;/my-path&amp;#39; })

// fetches the remote view at /my-lazy-container and uses it to replace the component with id &amp;#39;lazy&amp;#39;
beagleView.fetch({ path: &amp;#39;/my-lazy-container&amp;#39; }, &amp;#39;lazy&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt; can accept 3 parameters, they are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;loadParams:&lt;/strong&gt; required. object containing the parameters to control the request, the options are the following:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt;: required. Path to the view in the backend.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;fallback:&lt;/strong&gt; optional. A Beagle Tree to fallback to in case of an error.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;method:&lt;/strong&gt; optional. &lt;code&gt;get&lt;/code&gt; by default. Use this option if you need another http method.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;headers:&lt;/strong&gt; optional. Use this option to pass additional headers to this single request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;shouldShowLoading:&lt;/strong&gt; optional. Tells wether to use or not the loadingComponent while the view loads. Will use the global configuration if not specified.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;shouldShowError:&lt;/strong&gt; optional. Tells wether or not to show the error component if the request fails. Will use the global configuration if not specified.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;strategy:&lt;/strong&gt; optional. Tells which &lt;a href=&#34;https://docs.usebeagle.io/resources/customization/beagle-para-web/cache-strategy&#34;&gt;&lt;strong&gt;cache strategy&lt;/strong&gt;&lt;/a&gt; should be used to load this specific view. Will use the global configuration if not specified.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;loadingComponent:&lt;/strong&gt; optional. The loading component to use. Will use the global configuration if not specified.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;errorComponent:&lt;/strong&gt; optional. The error component to use. Will use the global configuration if not specified.&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;anchor:&lt;/strong&gt; optional. Id of the node to attach the resulting view to. By default, it uses the root node and it uses to update a single branch.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;mode:&lt;/strong&gt; optional. How to attach the resulting view to the anchor, there are four modes:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;replaceComponent&lt;/code&gt;: default. Replaces the entire anchor with the result of the request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;replace&lt;/code&gt;: replaces the children of the anchor with the result of the request.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prepend&lt;/code&gt;: adds the result of the request at the start of the list of children of the anchor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt;: adds the result of the request at the end of the list of children of the anchor.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;subscribing-to-events&#34;&gt;Subscribing to events&lt;/h2&gt;
&lt;p&gt;You can subscribe to events in the Beagle View. There are two types of subscriptions, one that listens to every update to the tree (&lt;code&gt;beagleView.subscribe&lt;/code&gt;) and another that listens to every error in the fetch/renderization process (&lt;code&gt;beagleView.addErrorListener&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When calling &lt;code&gt;beagleView.subscribe&lt;/code&gt;, you must pass a single parameter, which is a function that receives the current rendered tree. See the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const unsubscribeLogger = beagleView.subscribe((newTree) =&amp;gt; {
  console.log(&amp;#39;The tree was updated!&amp;#39;)
  console.log(newTree)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To remove a listener, just call the function it returned. In the previous example &lt;code&gt;unsubscribeLogger()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Error listeners are registered in a similar way. The only difference is that they receive a list of errors:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const removeErrorListener = beagleView.addErrorListener((errors) =&amp;gt; {
  console.log(&amp;#39;Oops! An error just happened!&amp;#39;)
  console.log(errors)
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;By default, Beagle logs every error in the fetch/rendering process to the console. Once a custom error listener is added to the Beagle View, Beagle will stop logging errors by itself and use the treatment provided by the developer instead.&lt;/p&gt;
&lt;h2 id=&#34;destroying-the-beagle-view&#34;&gt;Destroying the Beagle View&lt;/h2&gt;
&lt;p&gt;To avoid memory leaks, the Beagle View must be destroyed if it won&amp;rsquo;t be used again. If you&amp;rsquo;re using Angular or React, there&amp;rsquo;s no need to worry about it, it will get done under the hood. If you&amp;rsquo;re using Beagle Web directly, you must call &lt;code&gt;beagleView.destroy()&lt;/code&gt; when the remote view is removed from the page.&lt;/p&gt;
&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;
&lt;p&gt;Below you can find all methods of the Beagle View and their description:&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Attribute&lt;/th&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Type&lt;/th&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Definition&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;subscribe&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;Receives the listener and returns a function to unsubscribe.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;
        &lt;p&gt;&lt;/p&gt;
        &lt;p&gt;&lt;b&gt;addErrorListener&lt;/b&gt;
        &lt;/p&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;the-beagle-view-1.md#subscribing-to-events&#34;&gt;&lt;b&gt;subscribes to errors&lt;/b&gt;&lt;/a&gt;&lt;b&gt;. &lt;/b&gt;Receives
        the listener and returns a function to remove the listener.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;fetch&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;a href=&#34;the-beagle-view-1.md#fetching-a-view&#34;&gt;&lt;b&gt;fetches a view from the backend&lt;/b&gt;&lt;/a&gt;&lt;b&gt; &lt;/b&gt;and
        uses it to update the current tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;getRenderer&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns &lt;a href=&#34;rendering.md#the-renderer-api&#34;&gt;&lt;b&gt;the renderer&lt;/b&gt;&lt;/a&gt; of
        the view. Can be used to update the tree directly.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;getTree&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns a copy of the currently rendered tree.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;getBeagleNavigator&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns the navigator.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;getBeagleService&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns the BeagleService that created this view.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;b&gt;destroy&lt;/b&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;destroys this view.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Rendering</title>
      <link>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/rendering/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zupit.github.io/docs-beagle/docs/resources/customization/beagle-for-web/advanced-topics/rendering/</guid>
      <description>
        
        
        &lt;hr&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

The features described here are only available in versions 1.2.0 and above.
&lt;/div&gt;

&lt;p&gt;We recommend you to read about  &lt;a href=&#34;data-structure.md&#34;&gt;&lt;strong&gt;Beagle tree data structure&lt;/strong&gt;&lt;/a&gt; in order to help you understand rendering.&lt;/p&gt;
&lt;p&gt;Every Beagle Web library has a very well defined process of how it fetches, process and renders a view. There&amp;rsquo;s an order that must always be respected and hook points where the developer can execute some code of his own (lifecycles).&lt;/p&gt;
&lt;p&gt;See the full rendering process of Beagle Web:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zupit.github.io/docs-beagle/docs-beagle/beagle-view.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The Beagle lifecycles are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeforeStart&lt;/li&gt;
&lt;li&gt;BeforeViewSnapshot&lt;/li&gt;
&lt;li&gt;AfterViewSnapshot&lt;/li&gt;
&lt;li&gt;BeforeRender&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They can be used as global hooks to the lifecycle:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const config = {
  // ...
  lifecycles: {
    beforeStart: (payload) =&amp;gt; {
      // ...
    },
    beforeViewSnapshot: (payload) =&amp;gt; {
      // ...
    },
    afterViewSnapshot: (payload) =&amp;gt; {
      // ...
    },
    beforeRender: (payload) =&amp;gt; {
      // ...
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Or local hooks to the lifecycles in a per-component basis (annotations/decorators):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;// Attention: these won&amp;#39;t work with production builds in Angular. Keep reading for more details.

@BeforeStart((textComponentPayload) =&amp;gt; {
  // ...
})
@BeforeViewSnapshot((textComponentPayload) =&amp;gt; {
  // ...
})
@AfterViewSnapshot((textComponentPayload) =&amp;gt; {
  // ...
})
@BeforeRender((textComponentPayload) =&amp;gt; {
  // ...
})
@Component({
  // ...
})
class Text {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The example above won&amp;rsquo;t work with Angular when building for production, because of the  Angular compiler. To write a readable code you must choose one of two options:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Place the comment &lt;code&gt;// @dynamic&lt;/code&gt; before calling the decorator:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;// @dynamic
@BeforeRender((textComponentPayload) =&amp;gt; {
  // ...
})
@Component({
  // ...
})
class Text {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Replace the arrow function for a common function and export it:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;export function beforeRender(textComponentPayload) {
  // ...
}

@BeforeRender(beforeRender)
@Component({
  // ...
})
class Text {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since annotations/decorators cannot be used for functions, if you have a functional component or if you simply don&amp;rsquo;t want to use decorators, you can use them as normal function calls:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const Table = (props) =&amp;gt; {
  // ...
}

BeforeStart((textComponentPayload) =&amp;gt; {
  // ...
})(Table)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is important to notice, mainly for React, where Higher Order Components (HOCs) are common, that the component to receive the decorator must be the final component. For instance, if you want to apply a hoc named &lt;code&gt;withTheme&lt;/code&gt; to your component:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const MyComponent: FC = () =&amp;gt; {
  // ...
}

// This is wrong, it has no effect!
// BeforeRender(myLifecycleFunction)(MyComponent)
// export default withTheme(MyComponent)

// You need to apply the decorator to the final component instead:
const MyComponentWithTheme = withTheme(MyComponent)
BeforeRender(myLifecycleFunction)(MyComponentWithTheme)
export default MyComponentWithTheme
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The return value of a lifecycle hook can be either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook.&lt;/p&gt;
&lt;p&gt;To take control over the rendering process, besides the lifecycles, Beagle also offers the &lt;a href=&#34;rendering.md#the-renderer-api&#34;&gt;&lt;strong&gt;Renderer API&lt;/strong&gt;&lt;/a&gt;&lt;strong&gt;,&lt;/strong&gt; which can be accessed through &lt;code&gt;BeagleView.getRenderer()&lt;/code&gt;. The BeagleView can be accessed via the &lt;code&gt;BeagleRemoteView&lt;/code&gt; component through the attributes &lt;code&gt;onCreateBeagleView&lt;/code&gt;, in Angular and &lt;code&gt;viewRef&lt;/code&gt;in React.&lt;/p&gt;
&lt;p&gt;Another way to get access to the &lt;code&gt;BeagleView&lt;/code&gt; is through the &lt;a href=&#34;rendering.md#the-viewcontentmanager-api&#34;&gt;&lt;strong&gt;ViewContentManager API&lt;/strong&gt;&lt;/a&gt;, which can be found under &lt;code&gt;this.viewContentManager&lt;/code&gt; in an Angular component that extends &lt;code&gt;BeagleComponent&lt;/code&gt;; or under &lt;code&gt;props.viewContentManager&lt;/code&gt; in a React component that implements the &lt;code&gt;BeagleComponent&lt;/code&gt; interface.&lt;/p&gt;
&lt;h2 id=&#34;process-and-lifecycles&#34;&gt;Process and lifecycles&lt;/h2&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

Lifecycles deprecates the feature middlewares. Middlewares will still be supported at least until the next major version (2.0.0) and they will be interpreted as they were part of the global lifecycle &lt;code&gt;beforeViewSnapshot&lt;/code&gt;.
&lt;/div&gt;

&lt;p&gt;Beagle Web has a very well defined process from when a new payload is received to the moment it gets rendered in the browser screen. We also have some &amp;ldquo;breakpoints&amp;rdquo; in this process where you do your own stuff, this is called breakpoints &amp;ldquo;lifecycles&amp;rdquo;.&lt;/p&gt;
&lt;h3 id=&#34;process-to-render-a-view&#34;&gt;Process to render a view&lt;/h3&gt;
&lt;p&gt;See below the steps to render a view:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Run the global &lt;strong&gt;beforeStart&lt;/strong&gt; hook;&lt;/li&gt;
&lt;li&gt;Run the &lt;strong&gt;beforeStart&lt;/strong&gt; hook of each component;&lt;/li&gt;
&lt;li&gt;Identify the children of each component considering the decorator &amp;ldquo;BeagleChildren&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;Assign an id to every node that doesn&amp;rsquo;t have one yet;&lt;/li&gt;
&lt;li&gt;Remove any properties of the object that has a null value (nulls are interpreted as inexistent in Beagle);&lt;/li&gt;
&lt;li&gt;If needed, pre-fetch views that could be accessed next;&lt;/li&gt;
&lt;li&gt;Run the global &lt;strong&gt;beforeViewSnapshot&lt;/strong&gt; hook;&lt;/li&gt;
&lt;li&gt;Run the &lt;strong&gt;beforeViewSnapshot&lt;/strong&gt; hook of each component;&lt;/li&gt;
&lt;li&gt;Takes a snapshot of the current tree and stores it. From now on, any reference to the current rendered tree will be referencing the copy.&lt;/li&gt;
&lt;li&gt;Starts processing a copy of the snapshotted view, the next lifecycles will run over this copy.&lt;/li&gt;
&lt;li&gt;Run the global &lt;strong&gt;afterViewSnapshot&lt;/strong&gt; hook;&lt;/li&gt;
&lt;li&gt;Run the &lt;strong&gt;afterViewSnapshot&lt;/strong&gt; hook of each component;&lt;/li&gt;
&lt;li&gt;Deserialize beagle actions into javascript functions;&lt;/li&gt;
&lt;li&gt;Evaluate contexts and expressions;&lt;/li&gt;
&lt;li&gt;Interpret styles, converting the Beagle styling syntax to css;&lt;/li&gt;
&lt;li&gt;Run the global &lt;strong&gt;beforeRender&lt;/strong&gt; hook;&lt;/li&gt;
&lt;li&gt;Run the &lt;strong&gt;beforeRender&lt;/strong&gt; hook of each component;&lt;/li&gt;
&lt;li&gt;Hand the component tree to the render function. This function is different in Angular and React.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lifecycles&#34;&gt;Lifecycles&lt;/h3&gt;
&lt;p&gt;There are four lifecycle hooks, but you probably want to use just two of them: &lt;code&gt;beforeViewSnapshot&lt;/code&gt; and &lt;code&gt;beforeRender&lt;/code&gt;. The main difference between them is that the first runs before any expression or action has been evaluated and the second runs after. Also important to notice is that, when using the &lt;a href=&#34;rendering.md#the-renderer-api&#34;&gt;&lt;strong&gt;Renderer API&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;doFullRender&lt;/code&gt; will run both lifecycles, but &lt;code&gt;doPartialRender&lt;/code&gt; will run only the &lt;code&gt;beforeRender&lt;/code&gt; lifecycle.&lt;/p&gt;
&lt;p&gt;A simple rule to decide if you want to alter the tree via &lt;code&gt;beforeViewSnapshot&lt;/code&gt; or &lt;code&gt;beforeRender&lt;/code&gt; is: if your modification doesn&amp;rsquo;t depend on the result of an expression, use &lt;code&gt;beforeViewSnapshot&lt;/code&gt; otherwise use&lt;code&gt;beforeRender&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A lifecycle hook receives the Beagle Tree and returns either nothing (undefined) or a tree. If it is a tree, the rendering process will discard the previous tree and start working on the tree returned by the hook. If it&amp;rsquo;s a global lifecycle, by &amp;ldquo;tree&amp;rdquo; we mean the entire Beagle Tree, if it&amp;rsquo;s a component lifecycle, by &amp;ldquo;tree&amp;rdquo;, we mean the branch corresponding to the component.&lt;/p&gt;
&lt;p&gt;Below, see detailed explanations and examples of each lifecycle:&lt;/p&gt;
&lt;h3 id=&#34;beforestart&#34;&gt;BeforeStart&lt;/h3&gt;
&lt;p&gt;This lifecycle runs before anything else. Here it should be done modifications that must happen before any id is assigned or any children property is computed. Since it runs so early, if the payload is not at all what Beagle expects, here is the place to completely change it.&lt;/p&gt;
&lt;p&gt;Since the children translation has not run yet, components decorated with &lt;code&gt;@BeforeStart&lt;/code&gt; might not run at all, since they might not be considered part of the tree. Take, for instance, a text inside a component &lt;code&gt;table&lt;/code&gt; that has its children defined by the property &lt;code&gt;rows&lt;/code&gt;. In this lifecycle, Beagle has no idea that &lt;code&gt;rows&lt;/code&gt; actually represents the children of &lt;code&gt;table&lt;/code&gt; and when traversing the tree, it would ignore everything inside &lt;code&gt;rows&lt;/code&gt;, including the text we mentioned.&lt;/p&gt;
&lt;p&gt;This is the only lifecycle where new nodes can be added to the tree and not have ids. Every lifecycle after this is run after the ids are assigned, i.e. if they add a new node, they must also provide its id.&lt;/p&gt;
&lt;h4 id=&#34;examples-of-usage&#34;&gt;Examples of usage&lt;/h4&gt;
&lt;h4 id=&#34;custom-id-generator&#34;&gt;&lt;strong&gt;Custom ID generator&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;This lifecycle can be used to ignore Beagle&amp;rsquo;s default id generation and use one of your own. Since Beagle only computes random ids for nodes without id&amp;rsquo;s, you can use this lifecycle to assign your own unique ids to every node.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const config = {
  // ...
  lifecycles: {
    beforeStart: (tree) =&amp;gt; {
      let next = 1
      
      function assignIds(data: any) {
        // if it&amp;#39;s not a component or not a structure that can have a component inside, return
        if (!data || typeof data !== &amp;#39;object&amp;#39;) return
        // if it&amp;#39;s an array, assign ids to the components inside
        if (Array.isArray(data)) return data.forEach(assignIds)
        // if it is a component node, assign an ID
        if (data._beagleComponent_) data.id = `myAppID-${next++}`
        // if it&amp;#39;s an object, assign ids to the components inside
        const keys = Object.keys(data)
        keys.forEach(key =&amp;gt; assignIds(data[key]))
      }

      assignIds(tree)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Complex children calculation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Another use case would be complex &lt;code&gt;children&lt;/code&gt; calculations. Let&amp;rsquo;s say the children of a table component is actually the union of three properties: &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;rows&lt;/code&gt; and &lt;code&gt;footer&lt;/code&gt;. This cannot be expressed via the decorator &lt;code&gt;@BeagleChildren&lt;/code&gt; and is not at all what Beagle expects. This lifecycle could be used to remove these properties from the original JSON and create the property children, which would be the union of the three.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { BeforeStart } from &amp;#39;@zup-it/beagle-web&amp;#39;

@BeforeStart((table) =&amp;gt; {
  table.children = [header, ...rows, footer]
  delete table.header
  delete table.rows
  delete table.footer
})
class Table {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The code above works only if every other component has &lt;code&gt;children&lt;/code&gt; as the name of the property that represents its children. If this is not the case, a global lifecycle should be used instead.&lt;/p&gt;
&lt;p&gt;This feature could also be implemented using &lt;code&gt;BeforeViewSnapshot&lt;/code&gt;, but, in this case, you&amp;rsquo;d have to assign id&amp;rsquo;s to every node inside the new property &lt;code&gt;children&lt;/code&gt;, since in &lt;code&gt;BeforeViewSnapshot&lt;/code&gt; the ids have already been assigned. See the example &lt;a href=&#34;rendering.md#example-of-usage&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;beforeviewsnapshot&#34;&gt;BeforeViewSnapshot&lt;/h3&gt;
&lt;p&gt;Runs just before the view snapshot, useful to alter the payload, but after the ids were already assigned. This is where you should do most of your modifications to the tree, since id&amp;rsquo;s have already been assigned and the tree structure is ready to be traversed.&lt;/p&gt;
&lt;p&gt;The only thing we must be aware of is: if we create any new node, we must assign an id to it.&lt;/p&gt;
&lt;h4 id=&#34;example-of-usage&#34;&gt;Example of usage&lt;/h4&gt;
&lt;h3 id=&#34;writing-a-shortcut-to-control-text-inputs&#34;&gt;&lt;strong&gt;Writing a shortcut to control text-inputs&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The component &lt;code&gt;beagle:textInput&lt;/code&gt; can be controlled through a context. Let&amp;rsquo;s see an example where the value of the input &amp;ldquo;email&amp;rdquo; is controlled by the context property &lt;code&gt;email.address&lt;/code&gt; and the input &amp;ldquo;message&amp;rdquo; is controlled by the context property &lt;code&gt;email.message&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;{
  &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:container&amp;#34;,
  &amp;#34;context&amp;#34;: {
    &amp;#34;id&amp;#34;: &amp;#34;email&amp;#34;,
    &amp;#34;value&amp;#34;: {
      &amp;#34;address&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;
    }
  },
  &amp;#34;children&amp;#34;: [
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:textInput&amp;#34;,
      &amp;#34;placeholder&amp;#34;: &amp;#34;E-mail&amp;#34;,
      &amp;#34;value&amp;#34;: &amp;#34;@{email.address}&amp;#34;,
      &amp;#34;onChange&amp;#34;: [
        {
          &amp;#34;_beagleAction_&amp;#34;: &amp;#34;beagle:setContext&amp;#34;,
          &amp;#34;contextId&amp;#34;: &amp;#34;email&amp;#34;,
          &amp;#34;path&amp;#34;: &amp;#34;address&amp;#34;,
          &amp;#34;value&amp;#34;: &amp;#34;@{onChange.value}&amp;#34;
        }
      ]
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:textInput&amp;#34;,
      &amp;#34;placeholder&amp;#34;: &amp;#34;Message&amp;#34;,
      &amp;#34;value&amp;#34;: &amp;#34;@{email.message}&amp;#34;,
      &amp;#34;onChange&amp;#34;: [
        {
          &amp;#34;_beagleAction_&amp;#34;: &amp;#34;beagle:setContext&amp;#34;,
          &amp;#34;contextId&amp;#34;: &amp;#34;email&amp;#34;,
          &amp;#34;path&amp;#34;: &amp;#34;message&amp;#34;,
          &amp;#34;value&amp;#34;: &amp;#34;@{onChange.value}&amp;#34;
        }
      ]
    },
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is possible to add a shortcut. Let&amp;rsquo;s say whenever the json brings the property &lt;code&gt;model&lt;/code&gt; we create the entire structure automatically? In &lt;code&gt;model&lt;/code&gt;, it must be typed which value in the context will control the input. Let&amp;rsquo;s see the same example, but now using this new property &lt;code&gt;model&lt;/code&gt; that we just came up with.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;{
  &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:container&amp;#34;,
  &amp;#34;context&amp;#34;: {
    &amp;#34;id&amp;#34;: &amp;#34;email&amp;#34;,
    &amp;#34;value&amp;#34;: {
      &amp;#34;address&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;
    }
  },
  &amp;#34;children&amp;#34;: [
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:textInput&amp;#34;,
      &amp;#34;placeholder&amp;#34;: &amp;#34;E-mail&amp;#34;,
      &amp;#34;model&amp;#34;: &amp;#34;email.address&amp;#34;
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:textInput&amp;#34;,
      &amp;#34;placeholder&amp;#34;: &amp;#34;Message&amp;#34;,
      &amp;#34;model&amp;#34;: &amp;#34;email.message&amp;#34;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Much simpler, right? But for this to work, we still need to write the lifecycle that will transform &lt;code&gt;model&lt;/code&gt; to the expected structure.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { BeforeViewSnapshot } from &amp;#39;@zup-it/beagle-web&amp;#39;

@BeforeViewSnapshot((component) =&amp;gt; {
  component.value = `@{${component.model}}`
  component.onChange = component.onChange || []
  const [contextId, ...path] = component.model.split(&amp;#39;.&amp;#39;)
  component.onChange.push({
    _beagleAction_: &amp;#39;beagle:setContext&amp;#39;,
    contextId,
    path: path ? path.join(&amp;#39;.&amp;#39;) : undefined,
    value: &amp;#34;@{onChange.value}&amp;#34;
  })
})
@Component({
  // ...
})
class TextInput {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With this code, despite receiving &lt;code&gt;model&lt;/code&gt; from the backend, the payload processed by Beagle will have the expected values.&lt;/p&gt;
&lt;p&gt;This example might not have worked if it was placed under the lifecycle &lt;code&gt;BeforeStart&lt;/code&gt;. This is because, at this time, the children wouldn&amp;rsquo;t have been interpreted yet. Let&amp;rsquo;s say we had a component &lt;code&gt;custom:table&lt;/code&gt; where the children is placed under the property &lt;code&gt;rows&lt;/code&gt; and inside one of the rows there was a &lt;code&gt;beagle:textInput&lt;/code&gt;. The property &lt;code&gt;model&lt;/code&gt; wouldn&amp;rsquo;t be transformed for this particular text input, because, by this time (&lt;code&gt;BeforeStart&lt;/code&gt;), Beagle still has no idea that &lt;code&gt;rows&lt;/code&gt; are the &lt;code&gt;children&lt;/code&gt; of a &lt;code&gt;custom:table&lt;/code&gt; and the &lt;code&gt;beagle:textInput&lt;/code&gt; would&amp;rsquo;ve been inaccessible.&lt;/p&gt;
&lt;h3 id=&#34;complex-children-calculation-with-beforeviewsnapshot&#34;&gt;&lt;strong&gt;Complex children calculation with BeforeViewSnapshot&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;The example from the previous lifecycle (BeforeStart) could also have been done here without the danger of skipping the component&amp;rsquo;s lifecycle due to a children property named incorrectly. The only difference is that we&amp;rsquo;d must assign the ids ourselves:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { BeforeViewSnapshot, Tree, Component } from &amp;#39;@zup-it/beagle-web&amp;#39;

@BeforeStart((table) =&amp;gt; {
  table.children = [header, ...rows, footer]
  delete table.header
  delete table.rows
  delete table.footer
  // assigns a random id for each component in the tree table.children
  Tree.forEach(table.children, Component.assignId)
})
class Table {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;afterviewsnapshot&#34;&gt;AfterViewSnapshot&lt;/h3&gt;
&lt;p&gt;When using the &lt;a href=&#34;rendering.md#the-renderer-api&#34;&gt;&lt;strong&gt;Renderer API&lt;/strong&gt;&lt;/a&gt; we have two different types of render: full renders and partial renders. The two previous lifecycles will run only in full renders, while this lifecycle and the next runs on both full and partial renders.&lt;/p&gt;
&lt;p&gt;Differently from the two previous lifecycles, the changes done here are valid for the current render only. Since any update to the view is done over a tree based on the snapshotted view, the modifications done in this lifecycle are not permanent and will be executed in every render. For instance, if we have a property &lt;code&gt;counter&lt;/code&gt; with the value &lt;code&gt;0&lt;/code&gt; in the tree and in our lifecycle we increment &lt;code&gt;counter&lt;/code&gt; by &lt;code&gt;1&lt;/code&gt;. In the 5th full render these would be the values for &lt;code&gt;counter&lt;/code&gt; depending on which lifecycle was used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeforeStart: 5&lt;/li&gt;
&lt;li&gt;BeforeViewSnapshot: 5&lt;/li&gt;
&lt;li&gt;AfterViewSnapshot: 1&lt;/li&gt;
&lt;li&gt;BeforeRender: 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This lifecycle can be used to run code that needs to run every time the view is rendered but doesn&amp;rsquo;t require actions, context, expressions and styles to have already been processed.&lt;/p&gt;
&lt;h4 id=&#34;example-of-usage-1&#34;&gt;Example of usage&lt;/h4&gt;
&lt;p&gt;Contexts are defined, referenced and manipulated in the JSON of the view. But what if we want to access data of the application and not the view itself? Beagle offers a feature called &amp;ldquo;&lt;a href=&#34;https://docs.usebeagle.io/api/global-context&#34;&gt;&lt;strong&gt;Global context&lt;/strong&gt;&lt;/a&gt;&amp;rdquo; that is able to deal with this scenario, but suppose there is no Global context, we can still implement this behavior by using the AfterViewSnapshot lifecycle.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say we have a financial application and we want to show the user&amp;rsquo;s balance. We must guarantee that, in every re-render the most recent value for the balance will be used.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;{
  &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;container&amp;#34;,
  &amp;#34;context&amp;#34;: {
    &amp;#34;id&amp;#34;: &amp;#34;user&amp;#34;,
    &amp;#34;value&amp;#34;: {
      &amp;#34;name&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;balance&amp;#34;: 0
    }
  },
  &amp;#34;children&amp;#34;: [
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;text&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;@{user.name}, your balance is $@{user.balance}&amp;#34;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the JSON above, we use the context &lt;code&gt;user&lt;/code&gt;, where it starts with empty values and the view has no way of knowing the correct values. Now, replace the values of the context in the JSON by the values you have in your application. See the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import Tree from &amp;#39;@zup-it/beagle-web&amp;#39;

function findContextById(tree, id) {
  const it = Tree.iterator(tree)
  let next = it.next()
  while (!next.done) {
    const component = next.value
    if (component.context &amp;amp;&amp;amp; component.context.id === id) return component.context
    next = it.next()
  }
}

const config = {
  // ...
  lifecycles: {
    afterViewSnapshot: (payload) =&amp;gt; {
      const userContext = findContextById(payload, &amp;#39;user&amp;#39;)
      const userData = getUserData() // this method gets the user data from the application
      userContext.name = userData.name
      userContext.balance = userData.balance
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The code above tells Beagle to replace the values in the context &amp;ldquo;user&amp;rdquo; by the values in the application. This piece of code cannot be placed before the view is snapshotted because we have the requirement to update the balance value in every render. It also can&amp;rsquo;t be placed in the next lifecycle (BeforeRender), because the context would then be already evaluated and our values wouldn&amp;rsquo;t be processed.&lt;/p&gt;
&lt;p&gt;It is important to notice that the action &lt;code&gt;setContext&lt;/code&gt; would not work over the context &lt;code&gt;user&lt;/code&gt;, since we are always replacing the values for this context before processing any expression. This is just an example to show how this lifecycle could be used. To use application values in your beagle view, it is always preferred to use the &lt;a href=&#34;https://docs.usebeagle.io/api/global-context&#34;&gt;&lt;strong&gt;global context&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;beforerender&#34;&gt;BeforeRender&lt;/h3&gt;
&lt;p&gt;The changes here are valid for the current render only and is executed in every render. The difference from BeforeRender to AfterViewSnapshot, is that it is guaranteed that all actions, expressions and styles have already been processed.&lt;/p&gt;
&lt;h4 id=&#34;example-of-usage-2&#34;&gt;Example of usage&lt;/h4&gt;
&lt;p&gt;When the backend decided to express colors in the following format: &lt;code&gt;{ red: number, green: number, blue: number }&lt;/code&gt;. For example, black would be &lt;code&gt;{ red: 0, green: 0, blue: 0 }&lt;/code&gt;. This is not a valid color for browsers, so we decide to convert the value of every color property to a valid RGB format. Basically, the function that could do this work is the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const colorProperties: [&amp;#39;color&amp;#39;, &amp;#39;backgroundColor&amp;#39;, &amp;#39;borderColor&amp;#39;]

function fixColorCodes(componentPayload) {
  const style = componentPayload.style
  if (!style) return
  colorProperties.forEach((property) =&amp;gt; {
    if (!style[property]) return
    style[property] = `rgb(${style[property].red}, ${style[property].green}, ${style[property].blue})`
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, just need to run the function above for every component in the tree. If you want to have a dynamic behavior for the color by changing it via the context feature, check the JSON below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;{
  &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:container&amp;#34;,
  &amp;#34;context&amp;#34;: {
    &amp;#34;id&amp;#34;: &amp;#34;bgColor&amp;#34;,
    &amp;#34;value&amp;#34;: {
      &amp;#34;red&amp;#34;: 255,
      &amp;#34;green&amp;#34;: 255,
      &amp;#34;blue&amp;#34;: 255
    },
  },
  &amp;#34;children&amp;#34;: [
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:text&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;My dynamically colored text&amp;#34;,
      &amp;#34;style&amp;#34;: {
        &amp;#34;backgroundColor&amp;#34;: &amp;#34;@{bgColor}&amp;#34;
      }
    },
    {
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:button&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;red&amp;#34;,
      &amp;#34;onPress&amp;#34;: [
        {
          &amp;#34;_beagleAction_&amp;#34;: &amp;#34;setContext&amp;#34;,
          &amp;#34;contextId&amp;#34;: &amp;#34;bgColor&amp;#34;,
          &amp;#34;value&amp;#34;: {
            &amp;#34;red&amp;#34;: 255,
            &amp;#34;green&amp;#34;: 0,
            &amp;#34;blue&amp;#34;: 0
          }
        }
      ],
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:button&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;green&amp;#34;,
      &amp;#34;onPress&amp;#34;: [
        {
          &amp;#34;_beagleAction_&amp;#34;: &amp;#34;setContext&amp;#34;,
          &amp;#34;contextId&amp;#34;: &amp;#34;bgColor&amp;#34;,
          &amp;#34;value&amp;#34;: {
            &amp;#34;red&amp;#34;: 0,
            &amp;#34;green&amp;#34;: 255,
            &amp;#34;blue&amp;#34;: 0
          }
        }
      ],
      &amp;#34;_beagleComponent_&amp;#34;: &amp;#34;beagle:button&amp;#34;,
      &amp;#34;text&amp;#34;: &amp;#34;blue&amp;#34;,
      &amp;#34;onPress&amp;#34;: [
        {
          &amp;#34;_beagleAction_&amp;#34;: &amp;#34;setContext&amp;#34;,
          &amp;#34;contextId&amp;#34;: &amp;#34;bgColor&amp;#34;,
          &amp;#34;value&amp;#34;: {
            &amp;#34;red&amp;#34;: 0,
            &amp;#34;green&amp;#34;: 0,
            &amp;#34;blue&amp;#34;: 255
          }
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The text starts with a white background and as soon as the user presses a button, the background color changes.&lt;/p&gt;
&lt;p&gt;If you call &lt;code&gt;fixColorCodes&lt;/code&gt; before the context is evaluated, it will be trying to execute it over the string &lt;code&gt;@{bgColor}&lt;/code&gt; instead of the object &lt;code&gt;{ red: 255, green: 255, blue: 255 }&lt;/code&gt; which will get you a massive runtime error, since &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt; or &lt;code&gt;blue&lt;/code&gt; are not properties of a string.&lt;/p&gt;
&lt;p&gt;BeforeStart, BeforeViewSnapshot and AfterViewSnapshot are executed before the context gets evaluated, so everything that might be affected by the context, must be executed in the last lifecycle: BeforeRender.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { Tree } from &amp;#39;@zup-it/beagle-web&amp;#39;

const config = {
  // ...
  lifecycles: {
    // ...
    beforeRender: tree =&amp;gt; Tree.forEach(tree, fixColorCodes),
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-renderer-api&#34;&gt;The Renderer API&lt;/h2&gt;
&lt;p&gt;For fine control of the rendering process, Beagle also let you manage when to render a new tree to your Beagle View. You can have a component, that when clicks changes the current Beagle Tree, so a new component is added or a property is modified.&lt;/p&gt;
&lt;p&gt;A common scenario is when you need to create an action that modifies the current tree. Take for example the action &lt;code&gt;addChildren&lt;/code&gt;, when executed, it must get the current tree and add the given children to the component with the given &lt;code&gt;id&lt;/code&gt;. To do it, we must have a way to get the current tree, modify it and tell the Beagle View to render it again.&lt;/p&gt;
&lt;p&gt;A renderization can be one of two processes: a full renderization or a partial renderization. The first runs all steps of the renderization (1 to 8 in &lt;a href=&#34;rendering.md#process-to-render-a-view&#34;&gt;&lt;strong&gt;this list&lt;/strong&gt;&lt;/a&gt;). The second executes only the view snapshot and the steps after it (9 to 18 in &lt;a href=&#34;rendering.md#process-to-render-a-view&#34;&gt;&lt;strong&gt;this list&lt;/strong&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;h3 id=&#34;accessing-the-renderer&#34;&gt;Accessing the Renderer&lt;/h3&gt;
&lt;p&gt;Each Beagle View has its renderer, to get access to it, you must call &lt;code&gt;beagleView.getRenderer()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See examples of how to get the renderer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In React:  a reference to the &lt;code&gt;BeagleView&lt;/code&gt; can be obtained through the property &lt;code&gt;viewRef&lt;/code&gt; of the &lt;code&gt;BeagleRemoteView:&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import React, { FC, useRef, useEffect, MutableRefObject } from &amp;#39;react&amp;#39;
import { BeagleRemoteView } from &amp;#39;@zup-it/beagle-react&amp;#39;
import { BeagleView } from &amp;#39;@zup-it/beagle-web&amp;#39;

const Home: FC = () =&amp;gt; {
  const beagleView = useRef() as MutableRefObject&amp;lt;BeagleView | undefined&amp;gt;

  useEffect(() =&amp;gt; {
    if (beagleView.current) {
      const renderer = beagleView.current.getRenderer()
    }
  }, [])

  return (
    &amp;lt;BeagleRemoteView path=&amp;#34;/home&amp;#34; viewRef={beagleView} /&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;In Angular: you can use the attribute &lt;code&gt;onCreateBeagleView&lt;/code&gt; of the &lt;code&gt;beagle-remote-view&lt;/code&gt; component:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { Component } from &amp;#39;@angular/core&amp;#39;
import { LoadParams, BeagleView } from &amp;#39;@zup-it/beagle-web&amp;#39;

@Component({
  selector: &amp;#39;home&amp;#39;,
  template: &amp;#39;&amp;#39;,
})
export class Home {
  loadParams: LoadParams
  private beagleView: BeagleView

  constructor() {
    this.loadParams = { path: &amp;#39;/home&amp;#39; }
  }

  onCreateBeagleView(beagleView: BeagleView) {
    this.beagleView = beagleView
  }

  getRenderer() {
    return this.beagleView &amp;amp;&amp;amp; this.beagleView.getRenderer()
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When inside a component rendered by Beagle, you can use the &lt;a href=&#34;rendering.md#the-viewcontentmanager-api&#34;&gt;&lt;strong&gt;ViewContentManager&lt;/strong&gt;&lt;/a&gt; to get the BeagleView and obtain access to the renderer.&lt;/p&gt;
&lt;p&gt;When inside an action handler (custom actions), the Beagle View is provided via parameter, which can be used to get the renderer. See the example below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;const MyCustomActionHandler: ActionHandler&amp;lt;MyCustomAction&amp;gt; = ({ action, beagleView }) =&amp;gt; {
  const renderer = beagleView.getRenderer()
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;using-the-renderer&#34;&gt;Using the Renderer&lt;/h3&gt;
&lt;p&gt;The renderer has only two functions: &lt;code&gt;doFullRender&lt;/code&gt; and &lt;code&gt;doPartialRender&lt;/code&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;doFullRender&lt;/code&gt;: renders the tree passed as parameter by running all rendering steps over it. Full renders must be done every time new nodes are created&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doPartialRender&lt;/code&gt;: it only runs the view snapshot and the steps after that. Partial renders should be used to modify existent nodes.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The tree received by &lt;code&gt;doFullRender&lt;/code&gt; is of type &lt;code&gt;BeagleUIElement&lt;/code&gt;, for example,  it might or not have ids. The tree received by &lt;code&gt;doPartialRender&lt;/code&gt; is of type &lt;code&gt;IdentifiableBeagleUIElement&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Example: it must have ids for every node. You can never pass a tree to &lt;code&gt;doPartialRender&lt;/code&gt; with missing ids.&lt;/p&gt;
&lt;p&gt;Besides the type of the tree, there is no difference to the way we call &lt;code&gt;doFullRender&lt;/code&gt; and &lt;code&gt;doPartialRender&lt;/code&gt;. They both accept the following parameters:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first parameter is the tree.&lt;/li&gt;
&lt;li&gt;The second parameter is optional and it is the anchor. If the anchor is not specified, the tree passed in the first parameter will replace the entire currently rendered tree. If the anchor is specified, the tree passed as parameter will be attached to the currently rendered tree at the same position as the node with the id referenced by &lt;code&gt;anchor&lt;/code&gt;. How the attachment is done is defined by the third parameter.&lt;/li&gt;
&lt;li&gt;The third parameter is optional and it is the mode. If the mode is not defined, it is treated as &lt;code&gt;replaceComponent&lt;/code&gt;. There are four different modes:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;replaceComponent&lt;/code&gt;: replaces the node with the same id as the parameter &lt;code&gt;anchor&lt;/code&gt; (or the root if no anchor is specified) with the tree passed in the first parameter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt;: replaces the children of the node with the same id as the parameter &lt;code&gt;anchor&lt;/code&gt; (or the root if no anchor is specified) with the tree passed in the first parameter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepend&lt;/code&gt;: pre-pends the tree passed in the first parameter to the children of the node with the same id as the parameter &lt;code&gt;anchor&lt;/code&gt; (or the root if no anchor is specified).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append&lt;/code&gt;: appends the tree passed in the first parameter to the children of the node with the same id as the parameter &lt;code&gt;anchor&lt;/code&gt; (or the root if no anchor is specified).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;examples&#34;&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;/* example 1: renders a container with an empty list */
beagleView.getRenderer().doFullRender({
  _beagleComponent_: &amp;#39;beagle:container&amp;#39;,
  children: [
    _beagleComponent_: &amp;#39;custom:list&amp;#39;,
    id: &amp;#39;list&amp;#39;,
  ],
})

/* example 2: adds a property to the root of the currently rendered tree */
const current = beagleView.getTree()
current.newProperty = &amp;#39;new&amp;#39;
beagleView.getRenderer().doPartialRender(current)

/* example 3: adds an element to the &amp;#34;custom:list&amp;#34; inside the container */
const item = {
  _beagleComponent_: &amp;#39;beagle:container&amp;#39;,
  children: [
    { _beagleComponent_: &amp;#39;beagle:text&amp;#39;, text: &amp;#39;Client name: Jasnah Kholin&amp;#39; },
    { _beagleComponent_: &amp;#39;beagle:text&amp;#39;, text: &amp;#39;Client age: 30&amp;#39; }
  ]
}
// we should always do full renders when creating new nodes
beagleView.getRenderer().doFullRender(item, &amp;#39;list&amp;#39;, { mode: &amp;#39;append&amp;#39; })
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;

&lt;p&gt;With the renderer API you get to alter the view whenever you want. You can&amp;rsquo;t, for instance, call &lt;code&gt;renderer.doFullRender(tree, componentId)&lt;/code&gt; in the &lt;code&gt;onInit&lt;/code&gt; of the Angular component with id &lt;code&gt;componentId&lt;/code&gt;. If this is done, Beagle will remove a component of the tree before it even gets the chance to be fully rendered. Cases like this can happen using the Beagle Renderer inside components lifecycles, so be careful!&lt;/p&gt;
&lt;p&gt;A solution to the example given would be to replace the children of the component instead of the component itself (&lt;code&gt;renderer.doFullRender(tree, componentId, &#39;replace&#39;)&lt;/code&gt;).&lt;/p&gt;

&lt;/div&gt;

&lt;h2 id=&#34;the-viewcontentmanager-api&#34;&gt;The ViewContentManager API&lt;/h2&gt;
&lt;p&gt;List view component is a component that needs to use the Renderer API, but how do we access the renderer from the component itself? In both Angular and React this can be done via the &lt;code&gt;ViewContentManager&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The ViewContentManager provides a way to access the Beagle View and the node in the current Beagle Tree that gave origin to the component being rendered and with that you can access the renderer and call re-renders for this specific component.&lt;/p&gt;
&lt;h3 id=&#34;accessing-the-viewcontentmanager&#34;&gt;Accessing the ViewContentManager&lt;/h3&gt;
&lt;h4 id=&#34;react&#34;&gt;React&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;ViewContentManager&lt;/code&gt; can be accessed inside a React component if this component implements the BeagleComponent interface.&lt;/p&gt;
&lt;p&gt;See below an example to re-render the component with a new set of children based on the data source and the template:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import React, { FC, useRef, useEffect, MutableRefObject } from &amp;#39;react&amp;#39;
import { BeagleComponent } from &amp;#39;@zup-it/beagle-react&amp;#39;

interface ListViewInterface extends BeagleComponent {
  // ...
}

const ListView: FC&amp;lt;ListViewInterface&amp;gt; = (props) =&amp;gt; {
  useEffect(() =&amp;gt; {
    /* Once the component implements the BeagleComponent interface, we have access to the
    viewContentManager, but if the component was not instantiated by Beagle, the viewContentManager
    will be undefined. We must verify it before continuing. */ 
    if (!props.viewContentManager) return
    const children = createChildrenFromTemplate(props.dataSource, props.template)
    const element = props.viewContentManager.getElement()
    element.children = children
    props.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id)
  }, [props.dataSource, props.template])

  return (
    // ...
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The re-render happens every time the data source or the template changes.&lt;/p&gt;
&lt;h4 id=&#34;angular&#34;&gt;Angular&lt;/h4&gt;
&lt;p&gt;In Angular,  if you need access to the ViewContentManager, the component class must extend &lt;code&gt;BeagleComponent&lt;/code&gt;, then, you just need to reference &lt;code&gt;this.viewContentManager&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;import { Component, Input } from &amp;#39;@angular/core&amp;#39;
import { BeagleComponent } from &amp;#39;@zup-it/beagle-angular&amp;#39;

@Component({
  // ...
})
export class ListView extends BeagleComponent {
  // ...

  renderDataSource() {
    /* Checks if the viewContentManager is available. If the components has not been created by
    Beagle, it won&amp;#39;t be. */
    if (!this.viewContentManager) return
    const children = this.createChildrenFromTemplate(this.dataSource, this.template)
    const element = this.viewContentManager.getElement()
    element.children = children
    this.viewContentManager.getBeagleView().getRenderer().doFullRenderer(element, element.id)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method &lt;code&gt;renderDataSource&lt;/code&gt; should be called every time the data source or the template changes.&lt;/p&gt;
&lt;h3 id=&#34;using-the-viewcontentmanager&#34;&gt;Using the ViewContentManager&lt;/h3&gt;
&lt;p&gt;The ViewContentManager have the following properties/functions&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Property&lt;/th&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Type&lt;/th&gt;
      &lt;th style=&#34;text-align:left&#34;&gt;Definition&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;
        &lt;p&gt;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;getElement()&lt;/code&gt;
        &lt;/p&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns the node in the Beagle Tree responsible for the renderization
        of the component.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;
        &lt;p&gt;&lt;/p&gt;
        &lt;p&gt;&lt;code&gt;getElementId()&lt;/code&gt;
        &lt;/p&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;shortcut to &lt;code&gt;getElement().id&lt;/code&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;&lt;code&gt;getBeagleView()&lt;/code&gt;
      &lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;function&lt;/td&gt;
      &lt;td style=&#34;text-align:left&#34;&gt;returns the BeagleView responsible for the view containing the component.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;updating-the-view-with-the-result-of-a-request&#34;&gt;Updating the view with the result of a request&lt;/h2&gt;
&lt;p&gt;In case you need to update the current view with a tree that comes from the backend, you should use &lt;a href=&#34;https://github.com/ZupIT/beagle-web-core/blob/master/docs/beagle-view.md#Fetching-a-view&#34;&gt;&lt;strong&gt;the method &lt;code&gt;fetch&lt;/code&gt; of the &lt;code&gt;BeagleView&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;. It will internally use all the cache mechanisms of Beagle and also do the rendering part.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
